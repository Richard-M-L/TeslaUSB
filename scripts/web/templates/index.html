{% extends "base.html" %}
{% block content %}
<div class="container">
    <div class="status-label {{ mode_class }}">å½“å‰æ¨¡å¼: {{ mode_label }}</div>
    <div class="info-box">
        <strong>è½¦è½½Uç›˜æ¨¡å¼:</strong> USBå·¥å…·ç®±åœ¨Teslaç³»ç»Ÿä¸­æ˜¾ç¤ºä¸ºUSBå­˜å‚¨è®¾å¤‡ã€‚USBå·¥å…·ç®±å‚¨å­˜çš„æ–‡ä»¶åªæœ‰è¯»å–ä¸‹è½½æƒé™ï¼Œæ— æ³•åˆ é™¤æ•´ç†ã€‚<br>
        <strong>ç¼–è¾‘æ¨¡å¼:</strong> æœ¬åœ°æŒ‚è½½çš„é©±åŠ¨å™¨ï¼Œå¯é€šè¿‡Sambaè®¿é—®ï¼Œå®ç°å®Œå…¨è¯»å†™æƒé™ã€‚
    </div>
</div>

<script>
function togglePassword(btn) {
    const passField = document.getElementById('ap_passphrase');
    if (passField.type === 'password') {
        passField.type = 'text';
        btn.textContent = 'éšè—';
    } else {
        passField.type = 'password';
        btn.textContent = 'æ˜¾ç¤º';
    }
}

function toggleWifiPassword(btn) {
    const passField = document.getElementById('wifi_password');
    if (passField.type === 'password') {
        passField.type = 'text';
        btn.textContent = 'éšè—';
    } else {
        passField.type = 'password';
        btn.textContent = 'æ˜¾ç¤º';
    }
}

function confirmWifiUpdate() {
    // Check if user is currently connected via WiFi (not AP)
    const connectedViaWifi = {{ 'true' if wifi_status.connected else 'false' }};
    const currentSSID = {{ wifi_status.current_ssid | tojson if wifi_status.get('current_ssid') else 'null' }};
    const apActive = {{ 'true' if ap_status.ap_active else 'false' }};
    const apIP = {{ ap_status.static_ip | tojson if ap_status.get('static_ip') else 'null' }};

    // Detect if user is accessing via AP IP
    const accessingViaAP = apIP && (window.location.hostname === apIP || window.location.hostname === apIP.split('/')[0]);

    let message = '';

    if (connectedViaWifi && !accessingViaAP && currentSSID) {
        // User is connected via WiFi directly (not through AP)
        message = 'âš ï¸ è­¦å‘Š: ä½ å½“å‰ä»…é€šè¿‡ ' + currentSSID + ' çš„ç½‘ç»œè¿æ¥è®¾å¤‡ã€‚\n\n';
        message += 'å¦‚æœä½ ä¿®æ”¹çš„WiFiå‡­è¯æœ‰è¯¯ï¼Œä½ å°†**ç«‹å³å¤±å»å½“å‰è¿æ¥**ï¼Œæ— æ³•ç»§ç»­è®¿é—®ç½‘é¡µï¼\n\n';
        message += 'ä¸è¿‡: å¤‡ç”¨APï¼ˆè®¾å¤‡çƒ­ç‚¹ï¼‰ ' + (apActive ? 'å·²å¼€å¯' : 'éšæ—¶å¯å¼€å¯') + '.\n';
        message += 'å¦‚æœæ–°WiFiè¿æ¥å¤±è´¥ï¼Œä½ å¯ä»¥é‡æ–°è¿æ¥åˆ°è®¾å¤‡çš„ AP çƒ­ç‚¹æ¥ä¿®å¤è®¾ç½®ã€‚\n\n';
        message += 'å¼ºçƒˆå»ºè®®ï¼šå…ˆè¿æ¥åˆ°è®¾å¤‡çš„ AP çƒ­ç‚¹ï¼Œå†è¿›è¡Œå‡­è¯ä¿®æ”¹ä¼šæ›´å®‰å…¨ã€‚\n\n';
        message += 'ä»è¦ç»§ç»­å—ï¼Ÿï¼ˆæœ‰æ–­è”é£é™©ï¼‰';
    } else if (accessingViaAP || apActive) {
        // User is accessing via AP - safe!
        message = 'âœ“ ä½ å½“å‰æ˜¯é€šè¿‡è®¾å¤‡çš„å¤‡ç”¨APï¼ˆçƒ­ç‚¹ï¼‰è¿æ¥çš„ï¼Œå¾ˆå®‰å…¨ã€‚\n\n';
        message += 'USBå·¥å…·ç®±ä¼šå°è¯•è¿æ¥ä½ è®¾ç½®çš„æ–°WiFiç½‘ç»œã€‚\n';
        message += 'åœ¨è¿æ¥è¿‡ç¨‹ä¸­ï¼Œä½ çš„APè¿æ¥ä¼šä¸€ç›´ä¿æŒå¯ç”¨ã€‚\n\n';
        message += 'ç»§ç»­æ“ä½œå—ï¼Ÿ';
    } else {
        // Not sure how they're connected - generic warning
        message = 'æ ‘è“æ´¾å°†å°è¯•è¿æ¥åˆ°æ–°çš„WiFi ç½‘ç»œã€‚\n';
        message += 'å¦‚æœè¿æ¥å¤±è´¥ï¼Œå¤‡ç”¨APï¼ˆè®¾å¤‡çƒ­ç‚¹ï¼‰ä»ç„¶å¯ç”¨ï¼Œä½ å¯ä»¥é‡æ–°è¿æ¥æ¥ä¿®æ”¹è®¾ç½®ã€‚\n\n';
        message += 'ç»§ç»­æ“ä½œå—ï¼Ÿ';
    }

    return confirm(message);
}

// Prevent multiple mode switch submissions
// Mode toggle elements
const modeToggleForm = document.getElementById('modeToggleForm');
const modeToggle = document.getElementById('modeToggle');
const editLabel = document.getElementById('editLabel');
const presentLabel = document.getElementById('presentLabel');
const loadingOverlay = document.getElementById('loadingOverlay');

// AP form elements
const apConfigForm = document.getElementById('apConfigForm');
const startApForm = document.getElementById('startApForm');
const stopApForm = document.getElementById('stopApForm');
const updateApBtn = document.getElementById('updateApBtn');
const startApBtn = document.getElementById('startApBtn');
const stopApBtn = document.getElementById('stopApBtn');
const apLoadingOverlay = document.getElementById('apLoadingOverlay');

// WiFi form elements
const wifiConfigForm = document.getElementById('wifiConfigForm');
const updateWifiBtn = document.getElementById('updateWifiBtn');

// Update label opacity based on current mode
function updateLabelOpacity() {
    if (modeToggle.checked) {
        // Present mode is active
        editLabel.style.opacity = '0.5';
        presentLabel.style.opacity = '1';
        presentLabel.style.fontWeight = '600';
        editLabel.style.fontWeight = '500';
    } else {
        // Edit mode is active
        editLabel.style.opacity = '1';
        presentLabel.style.opacity = '0.5';
        editLabel.style.fontWeight = '600';
        presentLabel.style.fontWeight = '500';
    }
}

// Initialize label opacity on page load
updateLabelOpacity();

// Handle toggle switch changes
modeToggle.addEventListener('change', function() {
    if (modeToggle.disabled) {
        return;
    }

    // Disable toggle and show loading
    modeToggle.disabled = true;
    loadingOverlay.style.display = 'flex';

    // Determine which mode to switch to
    const targetMode = modeToggle.checked ? 'present' : 'edit';
    const actionUrl = targetMode === 'present'
        ? '{{ url_for("mode_control.present_usb") }}'
        : '{{ url_for("mode_control.edit_usb") }}';

    // Update label opacity immediately for responsiveness
    updateLabelOpacity();

    // Submit the form
    fetch(actionUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
    })
    .then(response => {
        if (response.redirected) {
            window.location.href = response.url;
        } else {
            return response.text();
        }
    })
    .catch(error => {
        console.error('Error switching modes:', error);
        // Revert toggle on error
        modeToggle.checked = !modeToggle.checked;
        updateLabelOpacity();
        modeToggle.disabled = false;
        loadingOverlay.style.display = 'none';
        alert('æ¨¡å¼åˆ‡æ¢å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚');
    });
});

function disableApButtons() {
    updateApBtn.disabled = true;
    startApBtn.disabled = true;
    stopApBtn.disabled = true;
    updateApBtn.style.opacity = '0.5';
    startApBtn.style.opacity = '0.5';
    stopApBtn.style.opacity = '0.5';
    updateApBtn.style.cursor = 'not-allowed';
    startApBtn.style.cursor = 'not-allowed';
    stopApBtn.style.cursor = 'not-allowed';
    apLoadingOverlay.style.display = 'flex';
}

apConfigForm.addEventListener('submit', function(e) {
    if (updateApBtn.disabled) {
        e.preventDefault();
        return false;
    }
    disableApButtons();
});

startApForm.addEventListener('submit', function(e) {
    if (startApBtn.disabled) {
        e.preventDefault();
        return false;
    }
    disableApButtons();
});

stopApForm.addEventListener('submit', function(e) {
    if (stopApBtn.disabled) {
        e.preventDefault();
        return false;
    }
    disableApButtons();
});

wifiConfigForm.addEventListener('submit', function(e) {
    if (updateWifiBtn.disabled) {
        e.preventDefault();
        return false;
    }
    // Validate SSID is selected or entered
    const ssidInput = document.getElementById('wifi_ssid');
    if (!ssidInput.value.trim()) {
        e.preventDefault();
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª WiFi ç½‘ç»œï¼Œæˆ–è¾“å…¥éšè—ç½‘ç»œçš„ SSID');
        return false;
    }
    updateWifiBtn.disabled = true;
    updateWifiBtn.style.opacity = '0.5';
    updateWifiBtn.style.cursor = 'not-allowed';
    updateWifiBtn.textContent = 'æ­£åœ¨è¿æ¥...';
});

// WiFi network scanning functionality
const wifiSsidSelect = document.getElementById('wifi_ssid_select');
const wifiSsidInput = document.getElementById('wifi_ssid');
const wifiSsidHint = document.getElementById('wifi_ssid_hint');
const wifiPasswordRow = document.getElementById('wifi_password_row');
const wifiPasswordInput = document.getElementById('wifi_password');
const scanWifiBtn = document.getElementById('scanWifiBtn');

// Show/hide password field based on network security
function updatePasswordVisibility(secured) {
    if (secured) {
        wifiPasswordRow.style.display = 'block';
        wifiPasswordInput.required = true;
    } else {
        wifiPasswordRow.style.display = 'none';
        wifiPasswordInput.required = false;
        wifiPasswordInput.value = '';  // Clear password for open networks
    }
}

// Handle dropdown selection
wifiSsidSelect.addEventListener('change', function() {
    const value = this.value;
    const selectedOption = this.options[this.selectedIndex];
    const isSecured = selectedOption.dataset.secured !== 'false';  // Default to secured for hidden networks

    if (value === '__hidden__') {
        // Show text input for hidden SSID - assume secured (user can leave password blank if open)
        wifiSsidInput.style.display = 'block';
        wifiSsidHint.style.display = 'inline';
        wifiSsidInput.value = '';
        wifiSsidInput.focus();
        wifiSsidInput.required = true;
        updatePasswordVisibility(true);  // Show password for hidden networks (user can leave blank if open)
    } else if (value) {
        // Network selected from dropdown
        wifiSsidInput.style.display = 'none';
        wifiSsidHint.style.display = 'none';
        wifiSsidInput.value = value;
        wifiSsidInput.required = true;
        updatePasswordVisibility(isSecured);  // Show/hide password based on network security
    } else {
        // Nothing selected
        wifiSsidInput.style.display = 'none';
        wifiSsidHint.style.display = 'none';
        wifiSsidInput.value = '';
        updatePasswordVisibility(true);  // Default: show password field
    }
});

// Scan for WiFi networks
function scanWifiNetworks() {
    scanWifiBtn.disabled = true;
    scanWifiBtn.innerHTML = 'â³ æ‰«æä¸­...';
    scanWifiBtn.style.opacity = '0.7';

    fetch('{{ url_for("mode_control.scan_wifi_networks") }}')
        .then(response => response.json())
        .then(data => {
            // Remember current selection
            const currentValue = wifiSsidSelect.value;
            const currentHiddenValue = (currentValue === '__hidden__') ? wifiSsidInput.value : '';

            // Clear existing options except the first two
            while (wifiSsidSelect.options.length > 2) {
                wifiSsidSelect.remove(2);
            }

            if (data.success && data.networks && data.networks.length > 0) {
                // Add separator
                const separator = document.createElement('option');
                separator.disabled = true;
                separator.textContent = 'â”€â”€â”€ å¯ç”¨ç½‘ç»œ â”€â”€â”€';
                wifiSsidSelect.appendChild(separator);

                // Add networks sorted by signal strength
                data.networks.forEach(network => {
                    const option = document.createElement('option');
                    option.value = network.ssid;
                    option.dataset.secured = network.secured ? 'true' : 'false';
                    const signalIcon = getSignalIcon(network.signal);
                    const lockIcon = network.secured ? 'ğŸ”’' : '';
                    const signalPct = network.signal ? ` (${network.signal}%)` : '';
                    option.textContent = `${signalIcon} ${network.ssid}${signalPct} ${lockIcon}`;
                    wifiSsidSelect.appendChild(option);
                });

                // Restore selection if it still exists
                if (currentValue === '__hidden__') {
                    wifiSsidSelect.value = '__hidden__';
                    wifiSsidInput.value = currentHiddenValue;
                } else if (currentValue) {
                    // Check if previously selected network is still in list
                    const exists = Array.from(wifiSsidSelect.options).some(opt => opt.value === currentValue);
                    if (exists) {
                        wifiSsidSelect.value = currentValue;
                    }
                }
            } else {
                // No networks found or error
                const noNetworks = document.createElement('option');
                noNetworks.disabled = true;
                noNetworks.textContent = 'â”€â”€â”€ æœªæ‰¾åˆ°ä»»ä½•ç½‘ç»œ â”€â”€â”€';
                wifiSsidSelect.appendChild(noNetworks);
            }
        })
        .catch(error => {
            console.error('æ‰«æç½‘ç»œå¤±è´¥:', error);
        })
        .finally(() => {
            scanWifiBtn.disabled = false;
            scanWifiBtn.innerHTML = 'ğŸ”„ æ‰«æ';
            scanWifiBtn.style.opacity = '1';
        });
}

// Get signal strength indicator (using bars representation)
function getSignalIcon(signal) {
    const signalNum = parseInt(signal) || 0;
    if (signalNum >= 75) return '[==== ]';     // Excellent
    if (signalNum >= 50) return '[===  ]';     // Good
    if (signalNum >= 25) return '[==   ]';     // Fair
    return '[=    ]';                           // Weak
}

// Dismiss WiFi status alert
function dismissWifiStatus() {
    const alert = document.getElementById('wifiStatusAlert');
    if (alert) {
        alert.style.display = 'none';
    }
    // Also clear it on the server so it doesn't show again
    fetch('{{ url_for("mode_control.dismiss_wifi_status") }}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
    }).catch(error => {
        console.error('å…³é—­ WiFi çŠ¶æ€æç¤ºå¤±è´¥:', error);
    });
}

// Auto-scan networks on page load (delayed to not slow down initial render)
setTimeout(function() {
    scanWifiNetworks();
}, 500);
</script>
{% endblock %}
